<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Liquid Glass UI Shader</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #icons {
            position: absolute;
            top: 0;
            left: 0;
            transform-origin: center center;
            display: flex;
            gap: 12px;
            align-items: center;
            justify-content: center;
            pointer-events: none;
        }

        .app-icon {
            width: 24px;
            height: 24px;
        }
        a{position: absolute;
       top: 16px;
       right: 20px;
       background: rgba(255, 255, 255, 0.08);
       backdrop-filter: blur(10px);
       -webkit-backdrop-filter: blur(10px);
       color: white;
       font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', sans-serif;
       font-weight: 500;
       font-size: 13px;
       letter-spacing: 0.3px;
       padding: 6px 12px;
       border-radius: 10px;
       box-shadow: 0 4px 10px rgba(0,0,0,0.15);
       text-decoration: none;
       transition: background 0.3s ease;
       z-index: 1000;}

    </style>
</head>
<body>
<a href="https://github.com/bergice/liquidglass" target="_blank" 
   onmouseover="this.style.background='rgba(255,255,255,0.15)'"
   onmouseout="this.style.background='rgba(255,255,255,0.08)'">
    View on GitHub
</a>

<canvas id="canvas"></canvas>
<div id="icons" style="position: absolute; top: 0; left: 0; pointer-events: none;">
    <img src="./icon.png" alt="icon" class="app-icon" />
</div>
<script id="fragmentShader" type="x-shader/x-fragment">
precision mediump float;

uniform float u_dpr;
uniform sampler2D u_background;
uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform vec2 u_size;

varying vec2 v_uv;

vec3 blurBackground(vec2 uv, vec2 resolution) {
    vec3 result = vec3(0.0);
    float total = 0.0;
    float radius = 3.0;

    for (int x = -3; x <= 3; x++) {
        for (int y = -3; y <= 3; y++) {
            vec2 offset = vec2(float(x), float(y)) * 2.0 / resolution;
            float weight = exp(-(float(x * x + y * y)) / (2.0 * radius));
            result += texture2D(u_background, uv + offset).rgb * weight;
            total += weight;
        }
    }
    return result / total;
}

void main() {

    vec2 pixelUV = (v_uv * u_resolution) / u_dpr;
    vec2 center = u_mouse;
    vec2 size = u_size * 0.5;

    // ⭐ TRUE CIRCLE DISTANCE ⭐
    float dist = length(pixelUV - center) - min(size.x, size.y);

    if (dist > 1.0) {
        gl_FragColor = texture2D(u_background, v_uv);
        return;
    }

    // ⭐ RADIAL NORMAL ⭐
    vec2 delta = pixelUV - center;
    float len = length(delta);

    // avoid instability near center
    vec2 normal = len > 0.0001 ? delta / len : vec2(0.0, 0.0);

    float r = clamp(length(pixelUV - center) / min(size.x, size.y), 0.0, 1.0);

    float curvature = pow(r, 0.7);
    float eta = 1.0 / 1.5;

    // dome refraction
    vec2 refractVec = refract(-normal * curvature, normal, eta);
    vec2 curvedRefractUV = v_uv + refractVec * 0.03;

    // edge refraction
    float contourFalloff = exp(-abs(dist) * 0.4);
    vec2 refractVecContour = refract(vec2(0.0), normal, eta);
    vec2 uvContour = v_uv + refractVecContour * 0.35 * contourFalloff;

    float edgeWeight = smoothstep(0.0, 1.0, abs(dist));
    float radialWeight = smoothstep(0.5, 1.0, r);

    float combinedWeight = clamp(edgeWeight - radialWeight * 0.5, 0.0, 1.0);

    vec2 refractUV = mix(curvedRefractUV, uvContour, combinedWeight);

    vec3 refracted = texture2D(u_background, refractUV).rgb;
    vec3 blurred = blurBackground(refractUV, u_resolution);

    vec3 base = mix(refracted, blurred, 0.5);

    float edgeFalloff = smoothstep(0.01, 0.0, dist);
    base = mix(base, vec3(0.0), edgeFalloff * 0.1);

    float edge = 1.0 - smoothstep(0.0, 0.03, dist * -2.0);

    vec3 color = mix(base, vec3(0.7), edge * 0.6);

    gl_FragColor = vec4(color, 0.75);
}
</script>
<script id="vertexShader" type="x-shader/x-vertex">
    attribute vec2 a_position;
    varying vec2 v_uv;
    void main() {
        v_uv = vec2(a_position.x, -a_position.y) * 0.5 + 0.5;
        gl_Position = vec4(a_position, 0.0, 1.0);
    }
</script>
<script>
    const canvas = document.getElementById("canvas");
    const gl = canvas.getContext("webgl", { antialias: true }) || canvas.getContext("experimental-webgl", { antialias: true });
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    function resize() {
        const dpr = window.devicePixelRatio || 1;
        canvas.width = window.innerWidth * dpr;
        canvas.height = window.innerHeight * dpr;
        canvas.style.width = window.innerWidth + 'px';
        canvas.style.height = window.innerHeight + 'px';
        gl.viewport(0, 0, canvas.width, canvas.height);
    }
    window.addEventListener("resize", resize);
    resize();

    const vertexShaderSrc = document.getElementById("vertexShader").textContent;
    const fragmentShaderSrc = document.getElementById("fragmentShader").textContent;

    function compileShader(type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error("Shader compile error:", gl.getShaderInfoLog(shader));
            return null;
        }
        return shader;
    }

    const vertexShader = compileShader(gl.VERTEX_SHADER, vertexShaderSrc);
    const fragmentShader = compileShader(gl.FRAGMENT_SHADER, fragmentShaderSrc);

    if (!vertexShader || !fragmentShader) {
        throw new Error("Shader compilation failed. Check the console for errors.");
    }

    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error("Program link error:", gl.getProgramInfoLog(program));
    }
    gl.useProgram(program);

    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        -1, -1,
        1, -1,
        -1, 1,
        -1, 1,
        1, -1,
        1, 1
    ]), gl.STATIC_DRAW);

    const positionLocation = gl.getAttribLocation(program, "a_position");
    gl.enableVertexAttribArray(positionLocation);
    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

    const u_resolution = gl.getUniformLocation(program, "u_resolution");
    const u_mouse = gl.getUniformLocation(program, "u_mouse");
    const u_size = gl.getUniformLocation(program, "u_size");

    const background = gl.createTexture();
    const image = new Image();
    image.crossOrigin = "anonymous";
    image.src = "./background.jpeg";
    image.onload = () => {
        gl.bindTexture(gl.TEXTURE_2D, background);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.uniform1i(gl.getUniformLocation(program, "u_background"), 0);
        const u_dpr = gl.getUniformLocation(program, "u_dpr");
        gl.uniform1f(u_dpr, window.devicePixelRatio || 1);
        requestAnimationFrame(draw);
    };

    let targetMouse = [window.innerWidth  / 2, window.innerHeight / 2];
    let currentMouse = [...targetMouse];

    const iconWrapper = document.getElementById("icons");
    const numIcons = iconWrapper.children.length;
    const iconSize = 48;
    const iconGap = 12;

    const totalWidth = numIcons * iconSize + (numIcons - 1) * iconGap;
    const totalHeight = iconSize; // assuming 1 row

    const defaultWidth = totalWidth + 20;  // Add padding
    const defaultHeight = totalHeight + 20;
    let enlargedSize = [defaultWidth, defaultHeight];
    const defaultSize = [enlargedSize[0] * .5, enlargedSize[1] * .5];
    let targetSize = [...defaultSize];
    let currentSize = [...targetSize];

    canvas.addEventListener("mousemove", e => {
        targetMouse = [e.clientX, e.clientY];
    });

    let lastTime = performance.now();

    function draw(now) {
        const delta = (now - lastTime) / 1000;
        lastTime = now;

        const speed = 5.0; // animation speed in units per second

        // Tween position
        currentMouse[0] += (targetMouse[0] - currentMouse[0]) * speed * delta;
        currentMouse[1] += (targetMouse[1] - currentMouse[1]) * speed * delta;

        // Optional: animate size for hover effect
        targetSize[0] = enlargedSize[0];
        targetSize[1] = enlargedSize[1];

        // Tween size with delta time
        currentSize[0] += (targetSize[0] - currentSize[0]) * speed * delta;
        currentSize[1] += (targetSize[1] - currentSize[1]) * speed * delta;

        resize();
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.uniform2f(u_resolution, canvas.width, canvas.height);
        gl.uniform2f(u_mouse, currentMouse[0], currentMouse[1]);
        gl.uniform2f(u_size, currentSize[0], currentSize[1]);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, background);
        gl.drawArrays(gl.TRIANGLES, 0, 6);

        // Position the icon wrapper at the button center
        iconWrapper.style.transform = `
            translate(${currentMouse[0]}px, ${currentMouse[1]}px)
            translate(-50%, -50%)
        `;

        requestAnimationFrame(draw);
    }
</script>
</body>
</html>
